struct "Simple" {
    a "i32"
}

alias "Simple2" "Simple"

struct "Complex" {
    elems1 "[Simple;10]"
    elems2 "[Simple;9]"
    val "Simple"
    // reffed "&Simple"
    // array_ref "&[&Simple;2]"
    opaque "ptr"
    flag "bool"
}

enum "ErrorCode" {
    Ok 0
    FileNotFound 1
    Bad -3
}

tagged "OptionI32" {
    None
    Some { _0 "i32"; }
}

tagged "MyResult" {
    Ok { _0 "[u32;3]"; }
    Err { _0 "ErrorCode"; }
}

tagged "MyDeepResult" {
    Ok { _0 "MyResult"; }
    Err { _0 "OptionI32"; }
    FileNotFound { x "bool"; y "Simple"; }
}

union "Life" {
   simple "Simple"
   complex "OptionI32"
   empty "()"
}

struct "ContainsRefs" {
    valued "i32"
    reffed "&i32"
    deep_reffed "InnerContainsRefs"
}

tagged "InnerContainsRefs" {
    A { x "&u64"; y "&u8"; }
    B { z "&i16"; }
    C { w "bool"; }
}

fn "func1" {
    inputs { a "Complex"; b "Simple"; }
    outputs { out "()"; }
}

fn "func2" {
    inputs {
        a "[Complex;2]"
        b "[Simple;10]"
        c "()"
        d "f64"
    }
    outputs {
        out "Complex"
    }
}

fn "arraytime" {
    inputs {
        a "[i32;4]"
        b "[[i32;4];5]"
        // c "[[[&Simple;1];2];3]"
    }
}

fn "enumtime" {
    inputs {
        a "OptionI32"
        b "MyResult"
        c "MyDeepResult"
    }
}

fn "uniontime" {
    inputs {
        a "Life"
        b "[Life; 3]"
        c "&Life"
    }
}

fn "reftime" {
    inputs {
        a "i32"
        b "&i32"
        c "&Simple"
        d "ContainsRefs"
    }
}

fn "simple" {
    inputs {
        a "i32"
        b "i32"
    }
}